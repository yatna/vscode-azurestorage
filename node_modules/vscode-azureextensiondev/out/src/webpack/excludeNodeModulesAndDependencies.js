"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.md in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const FilemanagerWebpackPlugin = require("filemanager-webpack-plugin");
const path = require("path");
/**
 * Add instructions to the webpack configuration to exclude a given set of node_modules dependencies,
 * along with their dependencies.
 */
function excludeNodeModulesAndDependencies(projectRoot, webpackConfig, packageLockJson, moduleNames, log = () => { }) {
    const externalModulesClosure = getNodeModulesDependencyClosure(packageLockJson, moduleNames);
    const excludeEntries = getExternalsEntries(externalModulesClosure);
    const copyEntries = getNodeModuleCopyEntries(projectRoot, externalModulesClosure);
    // Tell webpack to not place our modules into bundles
    // tslint:disable-next-line:strict-boolean-expressions
    webpackConfig.externals = webpackConfig.externals || {};
    log('Excluded node modules (external node modules plus dependencies)', externalModulesClosure);
    Object.assign(webpackConfig.externals, excludeEntries);
    // Tell webpack to copy the given modules' sources into dist\node_modules
    //   so they can be found through normal require calls.
    // NOTE: copy-webpack-plugin doesn't work for this. See https://github.com/microsoft/vscode-azuretools/pull/403 and https://github.com/webpack-contrib/copy-webpack-plugin/issues/35
    // tslint:disable-next-line: strict-boolean-expressions
    webpackConfig.plugins = webpackConfig.plugins || [];
    webpackConfig.plugins.push(new FilemanagerWebpackPlugin({
        onEnd: {
            copy: copyEntries
        }
    }));
}
exports.excludeNodeModulesAndDependencies = excludeNodeModulesAndDependencies;
/**
 * Get the full set of node_modules modules plus their dependencies
 */
function getNodeModulesDependencyClosure(packageLock, moduleNames) {
    const closure = new Set();
    // tslint:disable-next-line:strict-boolean-expressions no-object-literal-type-assertion
    const dependencies = packageLock.dependencies || {};
    for (const moduleName of moduleNames) {
        if (dependencies[moduleName]) {
            closure.add(moduleName);
            // tslint:disable-next-line:no-non-null-assertion
            const subdeps = getDependenciesFromEntry(dependencies[moduleName], packageLock);
            for (const subdep of subdeps) {
                closure.add(subdep);
            }
        }
        else {
            throw new Error(`Could not find dependency entry for ${moduleName}`);
        }
    }
    return Array.from(closure)
        .sort();
}
exports.getNodeModulesDependencyClosure = getNodeModulesDependencyClosure;
function getDependenciesFromEntry(depEntry, packageLock) {
    // Example entry:
    //
    // "braces": {
    //     "version": "2.3.2",
    //     "requires": {
    //         "arr-flatten": "^1.1.0",
    //         "array-unique": "^0.3.2",
    //     },
    //     "dependencies": {
    //         "extend-shallow": {
    //             "version": "2.0.1",
    //             "requires": {
    //                 "is-extendable": "^0.1.0"
    //             }
    //         }
    //     }
    // },
    const closure = new Set();
    // tslint:disable-next-line:strict-boolean-expressions no-object-literal-type-assertion
    const dependencies = depEntry.dependencies || {};
    // tslint:disable-next-line:no-object-literal-type-assertion strict-boolean-expressions
    const requires = depEntry.requires || {};
    // Handle dependencies
    for (const moduleName of Object.keys(dependencies)) {
        closure.add(moduleName);
        // tslint:disable-next-line:no-non-null-assertion
        const dependenciesSubdeps = getDependenciesFromEntry(dependencies[moduleName], packageLock);
        for (const subdep of dependenciesSubdeps) {
            closure.add(subdep);
        }
    }
    // Handle requires that aren't listed in dependencies by resolving them at the top level
    const requiredModules = Object.getOwnPropertyNames(requires)
        .filter((m) => !(m in dependencies));
    const requiresSubdeps = getNodeModulesDependencyClosure(packageLock, requiredModules);
    for (const subdep of requiresSubdeps) {
        closure.add(subdep);
    }
    return Array.from(closure)
        .sort();
}
function getExternalsEntries(moduleNames) {
    const externals = {};
    for (const moduleName of moduleNames) {
        // We want a list of strings in this format:
        //
        //   'clipboardy': 'commonjs clipboardy'
        //
        // This means whenever we see an import/require of the form `require("clipboardy")`, then
        //   instead of processing the module into a bundle, do a regular module load of ("clipboardy") as a commonjs module.
        //
        externals[moduleName] = `commonjs ${moduleName}`;
    }
    return externals;
}
exports.getExternalsEntries = getExternalsEntries;
function getNodeModuleCopyEntries(projectRoot, moduleNames) {
    // e.g.
    // new FilemanagerWebpackPlugin([
    //     {
    //         onEnd: {
    //             copy: [
    //                 { source: '/root/node_modules/clipboardy', destination: '/root/dist/node_modules/clipboardy' }
    //     ...
    const copyEntries = [];
    for (const moduleName of moduleNames) {
        copyEntries.push({
            source: path.join(projectRoot, 'node_modules', moduleName),
            destination: path.join(projectRoot, 'dist', 'node_modules', moduleName)
        });
    }
    return copyEntries;
}
exports.getNodeModuleCopyEntries = getNodeModuleCopyEntries;
//# sourceMappingURL=excludeNodeModulesAndDependencies.js.map
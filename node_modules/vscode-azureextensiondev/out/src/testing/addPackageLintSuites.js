"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See LICENSE.md in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
// tslint:enable:typedef
function emptyIfUndefined(value) {
    // tslint:disable-next-line:strict-boolean-expressions no-object-literal-type-assertion
    return value || {};
}
/**
 * Sets up test suites against an extension package.json file (run this at global level or inside a suite, not inside a test)
 *
 * @param packageJson The extension's package.json contents as an object
 */
// tslint:disable:max-func-body-length
function addPackageLintSuites(getExtensionContext, getCommands, packageJsonAsObject, options) {
    const packageJson = packageJsonAsObject;
    //tslint:disable-next-line:strict-boolean-expressions
    const commandsRegisteredButNotInPackage = options.commandsRegisteredButNotInPackage || [];
    let _registeredCommands;
    function getRegisteredCommands() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!_registeredCommands) {
                // We must wait to call these until the tests are actually run, because suite() runs too early for extension activation
                assert(!!getExtensionContext(), 'The extension must be activated before any tests are run, otherwise its commands won\'t have been registered yet');
                const registeredCommands = yield getCommands();
                // Remove predefined IDs
                const predefinedCommandIds = getPredefinedCommandIdsForExtension();
                _registeredCommands = registeredCommands.filter((cmdId) => !predefinedCommandIds.some((c) => c === cmdId));
            }
            return _registeredCommands;
        });
    }
    const activationEvents = emptyIfUndefined(packageJson.activationEvents);
    // tslint:disable-next-line:typedef
    const contributes = emptyIfUndefined(packageJson.contributes);
    // tslint:disable-next-line:typedef
    const views = emptyIfUndefined(contributes.views);
    // tslint:disable-next-line:typedef
    const commands = emptyIfUndefined(contributes.commands);
    // All commands should start with the same prefix - get prefix from first command
    const extensionPrefixWithPeriod = commands[0].command.substr(0, commands[0].command.indexOf('.') + 1);
    function verifyStartsWithExtensionPrefix(name) {
        assert(name.startsWith(extensionPrefixWithPeriod), `Expected ${name} to start with ${extensionPrefixWithPeriod}`);
    }
    function getPredefinedCommandIdsForExtension() {
        const predefinedIds = [];
        for (const viewContainerName of Object.keys(views)) {
            // tslint:disable-next-line:typedef
            const viewContainer = views[viewContainerName];
            for (const view of viewContainer) {
                // vscode automatic creates focus commands for each view
                predefinedIds.push(`${view.id}.focus`);
            }
        }
        return predefinedIds;
    }
    suite('Activation events for views', () => __awaiter(this, void 0, void 0, function* () {
        for (const viewContainerName of Object.keys(views)) {
            // tslint:disable-next-line:typedef
            const viewContainer = views[viewContainerName];
            for (const view of viewContainer) {
                const activationEvent = `onView:${view.id}`;
                test(view.id, () => {
                    assert(activationEvents.some((evt) => evt === activationEvent), `Couldn't find activation event ${activationEvent}`);
                });
            }
        }
    }));
    suite('Activation events for commands in package.json', () => __awaiter(this, void 0, void 0, function* () {
        for (const cmd of commands) {
            const cmdId = cmd.command;
            const activationEvent = `onCommand:${cmdId}`;
            test(cmdId, () => __awaiter(this, void 0, void 0, function* () {
                verifyStartsWithExtensionPrefix(cmdId);
                const registeredCommands = yield getRegisteredCommands();
                assert(registeredCommands.some((c) => c === cmdId), `${cmdId} is in package.json but wasn't registered with vscode`);
                assert(activationEvents.some((evt) => evt === activationEvent), `Couldn't find activation event for command ${cmdId}`);
            }));
        }
        for (const event of activationEvents) {
            const onCommand = 'onCommand:';
            if (event.startsWith('onCommand')) {
                const cmdId = event.substr(onCommand.length);
                test(event, () => __awaiter(this, void 0, void 0, function* () {
                    const registeredCommands = yield getRegisteredCommands();
                    assert(registeredCommands.some((c) => c === cmdId), `${event} is in package.json but ${cmdId} wasn't registered with vscode`);
                    // tslint:disable-next-line:typedef
                    assert(commands.some(cmd => cmd.command === cmdId), `${event} is in package.json but ${cmdId} wasn't a command in package.json`);
                }));
            }
        }
    }));
    test('Activation events for commands registered with vscode', () => __awaiter(this, void 0, void 0, function* () {
        const registeredCommands = yield getRegisteredCommands();
        for (const cmd of registeredCommands) {
            const cmdId = cmd;
            const activationEvent = `onCommand:${cmdId}`;
            if (cmdId.startsWith(extensionPrefixWithPeriod)) {
                // tslint:disable-next-line:typedef
                const isInPackage = commands.some(c => c.command === cmdId);
                if (commandsRegisteredButNotInPackage.some((c) => c === cmdId)) {
                    assert(!isInPackage, `${cmdId} is in commandsRegisteredButNotInPackage but was found in package.json`);
                    assert(!activationEvents.some((evt) => evt === activationEvent), `${cmdId} is in commandsRegisteredButNotInPackage but has an activation event`);
                }
                else {
                    assert(isInPackage, `${cmdId} was registered as a command during extension activation but is not in package.json`);
                    assert(activationEvents.some((evt) => evt === activationEvent), `Couldn't find activation event for registered command ${cmdId}`);
                }
            }
        }
    }));
}
exports.addPackageLintSuites = addPackageLintSuites;
//# sourceMappingURL=addPackageLintSuites.js.map
"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
var TestInput;
(function (TestInput) {
    TestInput[TestInput["UseDefaultValue"] = 0] = "UseDefaultValue";
    TestInput[TestInput["BackButton"] = 1] = "BackButton";
})(TestInput = exports.TestInput || (exports.TestInput = {}));
class GoBackError extends Error {
    constructor() {
        super('Go back.');
    }
}
class TestUserInput {
    constructor(vscode) {
        this._inputs = [];
        this._vscode = vscode;
        this._onDidFinishPromptEmitter = new this._vscode.EventEmitter();
    }
    get onDidFinishPrompt() {
        return this._onDidFinishPromptEmitter.event;
    }
    runWithInputs(inputs, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            this._inputs = inputs;
            yield callback();
            assert.equal(this._inputs.length, 0, `Not all inputs were used: ${this._inputs.toString()}`);
        });
    }
    showQuickPick(items, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolvedItems = yield Promise.resolve(items);
            let result;
            const input = this._inputs.shift();
            if (input === undefined) {
                throw new Error(`No more inputs left for call to showQuickPick. Placeholder: '${options.placeHolder}'`);
            }
            else if (input === TestInput.BackButton) {
                throw new GoBackError();
            }
            else {
                if (resolvedItems.length === 0) {
                    throw new Error(`No quick pick items found. Placeholder: '${options.placeHolder}'`);
                }
                else if (input === TestInput.UseDefaultValue) {
                    result = resolvedItems[0];
                }
                else {
                    function qpiMatchesInput(qpi) {
                        return (input instanceof RegExp && (input.test(qpi.label) || (qpi.description && input.test(qpi.description)))) || qpi.label === input || qpi.description === input;
                    }
                    if (options.canPickMany) {
                        result = resolvedItems.filter(qpiMatchesInput);
                    }
                    else {
                        const resolvedItem = resolvedItems.find(qpiMatchesInput);
                        if (resolvedItem) {
                            result = resolvedItem;
                        }
                        else {
                            throw new Error(`Did not find quick pick item matching '${input}'. Placeholder: '${options.placeHolder}'`);
                        }
                    }
                }
                this._onDidFinishPromptEmitter.fire(result);
                return result;
            }
        });
    }
    showInputBox(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            const input = this._inputs.shift();
            if (input === undefined) {
                throw new Error(`No more inputs left for call to showInputBox. Placeholder: '${options.placeHolder}'. Prompt: '${options.prompt}'`);
            }
            else if (input === TestInput.BackButton) {
                throw new GoBackError();
            }
            else if (input === TestInput.UseDefaultValue) {
                if (!options.value) {
                    throw new Error('Can\'t use default value because none was specified');
                }
                else {
                    result = options.value;
                }
            }
            else if (typeof input === 'string') {
                if (options.validateInput) {
                    const msg = yield Promise.resolve(options.validateInput(input));
                    if (msg !== null && msg !== undefined) {
                        throw new Error(msg);
                    }
                }
                result = input;
            }
            else {
                throw new Error(`Unexpected input '${input}' for showInputBox.`);
            }
            this._onDidFinishPromptEmitter.fire(result);
            return result;
        });
    }
    // tslint:disable-next-line:no-any
    showWarningMessage(message, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            const input = this._inputs.shift();
            if (input === undefined) {
                throw new Error(`No more inputs left for call to showWarningMessage. Message: ${message}`);
            }
            else if (typeof input === 'string') {
                // tslint:disable-next-line:no-unsafe-any
                const matchingItem = args.find((item) => item.title === input);
                if (matchingItem) {
                    result = matchingItem;
                }
                else {
                    throw new Error(`Did not find message item matching '${input}'. Message: '${message}'`);
                }
            }
            else {
                throw new Error(`Unexpected input '${input}' for showWarningMessage.`);
            }
            this._onDidFinishPromptEmitter.fire(result);
            return result;
        });
    }
    showOpenDialog(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            const input = this._inputs.shift();
            if (input === undefined) {
                throw new Error(`No more inputs left for call to showOpenDialog. Message: ${options.openLabel}`);
            }
            else if (typeof input === 'string') {
                result = [this._vscode.Uri.file(input)];
            }
            else {
                throw new Error(`Unexpected input '${input}' for showOpenDialog.`);
            }
            this._onDidFinishPromptEmitter.fire(result);
            return result;
        });
    }
}
exports.TestUserInput = TestUserInput;
//# sourceMappingURL=TestUserInput.js.map
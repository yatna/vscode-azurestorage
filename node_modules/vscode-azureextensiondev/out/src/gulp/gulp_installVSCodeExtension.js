"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fse = require("fs-extra");
const os = require("os");
const path = require("path");
// tslint:disable-next-line: export-name
function gulp_installVSCodeExtension(publisherId, extensionName, useInsiders = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const extensionId = `${publisherId}.${extensionName}`;
        const vsCodeDir = useInsiders ? '.vscode-insiders' : '.vscode';
        const extensionsPath = path.join(os.homedir(), vsCodeDir, 'extensions');
        let existingExtensions = [];
        if (yield fse.pathExists(extensionsPath)) {
            existingExtensions = yield fse.readdir(extensionsPath);
        }
        if (!existingExtensions.some((e) => e.includes(extensionId))) {
            console.log(`"Installing" test extension with id "${extensionId}".`);
            const version = '0.0.1';
            const extensionPath = path.join(extensionsPath, `${extensionId}-${version}`);
            const packageJsonPath = path.join(extensionPath, 'package.json');
            const packageJson = {
                name: extensionName,
                displayName: "",
                publisher: publisherId,
                description: "",
                version: version,
                engines: {
                    vscode: "^1.31.0"
                },
                activationEvents: [],
                main: "./extension",
                contributes: {}
            };
            yield fse.ensureFile(packageJsonPath);
            yield fse.writeJSON(packageJsonPath, packageJson);
            const extensionJsPath = path.join(extensionPath, 'extension.js');
            const extensionJs = `exports.activate = function activate() { };exports.deactivate = function deactivate() { };`;
            yield fse.ensureFile(extensionJsPath);
            yield fse.writeFile(extensionJsPath, extensionJs);
        }
        else {
            console.log(`Extension with id "${extensionId}" already installed.`);
            // We need to signal to gulp that we've completed this async task
            return Promise.resolve();
        }
    });
}
exports.gulp_installVSCodeExtension = gulp_installVSCodeExtension;
//# sourceMappingURL=gulp_installVSCodeExtension.js.map
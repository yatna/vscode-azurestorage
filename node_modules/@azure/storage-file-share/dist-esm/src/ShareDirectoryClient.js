// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __assign, __asyncGenerator, __asyncValues, __await, __awaiter, __extends, __generator } from "tslib";
import { Directory } from "./generated/src/operations";
import { validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions, fileAttributesToString, fileCreationTimeToString, fileLastWriteTimeToString, validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions } from "./models";
import { newPipeline, Pipeline } from "./Pipeline";
import { appendToURLPath, getShareNameAndPathFromUrl } from "./utils/utils.common";
import { StorageClient } from "./StorageClient";
import "@azure/core-paging";
import { ShareFileClient } from "./ShareFileClient";
import { Credential } from "./credentials/Credential";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { FileSystemAttributes } from "./FileSystemAttributes";
import { createSpan } from "./utils/tracing";
import { CanonicalCode } from "@opentelemetry/types";
/**
 * A ShareDirectoryClient represents a URL to the Azure Storage directory allowing you to manipulate its files and directories.
 *
 * @export
 * @class ShareDirectoryClient
 */
var ShareDirectoryClient = /** @class */ (function (_super) {
    __extends(ShareDirectoryClient, _super);
    function ShareDirectoryClient(url, credentialOrPipeline, options) {
        var _a;
        if (options === void 0) { options = {}; }
        var _this = this;
        var pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        _this = _super.call(this, url, pipeline) || this;
        (_a = getShareNameAndPathFromUrl(_this.url), _this._name = _a.baseName, _this._shareName = _a.shareName, _this._path = _a.path);
        _this.context = new Directory(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ShareDirectoryClient.prototype, "shareName", {
        /**
         * The share name corresponding to this directory client
         *
         * @type {string}
         * @memberof ShareDirectoryClient
         */
        get: function () {
            return this._shareName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShareDirectoryClient.prototype, "path", {
        /**
         * The full path of the directory
         *
         * @type {string}
         * @memberof ShareDirectoryClient
         */
        get: function () {
            return this._path;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShareDirectoryClient.prototype, "name", {
        /**
         * The name of the directory
         *
         * @type {string}
         * @memberof ShareDirectoryClient
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new directory under the specified share or parent directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param {DirectoryCreateOptions} [options] Options to Directory Create operation.
     * @returns {Promise<DirectoryCreateResponse>} Response data for the Directory  operation.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, attributes, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (!options.fileAttributes) {
                            options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);
                            attributes = new FileSystemAttributes();
                            attributes.directory = true;
                            options.fileAttributes = attributes;
                        }
                        return [4 /*yield*/, this.context.create(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), {
                                abortSignal: options.abortSignal,
                                metadata: options.metadata,
                                filePermission: options.filePermission,
                                filePermissionKey: options.filePermissionKey,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets properties on the directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-properties
     *
     * @param {properties} [DirectoryProperties] Directory properties. If no values are provided,
     *                                            existing values will be preserved.
     * @returns {Promise<DirectorySetPropertiesResponse>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.setProperties = function (properties) {
        if (properties === void 0) { properties = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-setProperties", properties.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);
                        return [4 /*yield*/, this.context.setProperties(fileAttributesToString(properties.fileAttributes), fileCreationTimeToString(properties.creationTime), fileLastWriteTimeToString(properties.lastWriteTime), {
                                abortSignal: properties.abortSignal,
                                filePermission: properties.filePermission,
                                filePermissionKey: properties.filePermissionKey,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a ShareDirectoryClient object for a sub directory.
     *
     * @param subDirectoryName A subdirectory name
     * @returns {ShareDirectoryClient} The ShareDirectoryClient object for the given subdirectory name.
     * @memberof ShareDirectoryClient
     *
     * Example usage:
     *
     * ```js
     * const directoryClient = shareClient.getDirectoryClient("<directory name>");
     * await directoryClient.create();
     * console.log("Created directory successfully");
     * ```
     */
    ShareDirectoryClient.prototype.getDirectoryClient = function (subDirectoryName) {
        return new ShareDirectoryClient(appendToURLPath(this.url, encodeURIComponent(subDirectoryName)), this.pipeline);
    };
    /**
     * Creates a new subdirectory under this directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param {string} directoryName
     * @param {DirectoryCreateOptions} [options] Options to Directory Create operation.
     * @returns {Promise<{ directoryClient: ShareDirectoryClient; directoryCreateResponse: DirectoryCreateResponse; }>} Directory create response data and the corresponding DirectoryClient instance.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.createSubdirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, directoryClient, directoryCreateResponse, e_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-createSubdirectory", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.create(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        directoryCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                directoryClient: directoryClient,
                                directoryCreateResponse: directoryCreateResponse
                            }];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty sub directory under this directory.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param {string} directoryName
     * @param {DirectoryDeleteOptions} [options] Options to Directory Delete operation.
     * @returns {DirectoryDeleteResponse} Directory deletion response data.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.deleteSubdirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, directoryClient, e_4;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-deleteSubdirectory", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.delete(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new file or replaces a file under this directory. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param {string} fileName
     * @param {number} size Specifies the maximum size in bytes for the file, up to 1 TB.
     * @param {FileCreateOptions} [options] Options to File Create operation.
     * @returns {Promise<{ fileClient: ShareFileClient, fileCreateResponse: FileCreateResponse }>} File creation response data and the corresponding file client.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.createFile = function (fileName, size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, fileClient, fileCreateResponse, e_5;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-createFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        fileClient = this.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.create(size, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        fileCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                fileClient: fileClient,
                                fileCreateResponse: fileCreateResponse
                            }];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified file under this directory from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param {string} fileName Name of the file to delete
     * @param {FileDeleteOptions} [options] Options to File Delete operation.
     * @returns {Promise<FileDeleteResponse>} File deletion response data.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.deleteFile = function (fileName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, fileClient, e_6;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-deleteFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        fileClient = this.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.delete(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a {@link ShareFileClient} object.
     *
     * @param {string} fileName A file name.
     * @returns {ShareFileClient} A new ShareFileClient object for the given file name.
     * @memberof ShareFileClient
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!"
     *
     * const fileClient = directoryClient.getFileClient("<file name>");
     *
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * await fileClient.uplaodRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    ShareDirectoryClient.prototype.getFileClient = function (fileName) {
        return new ShareFileClient(appendToURLPath(this.url, encodeURIComponent(fileName)), this.pipeline);
    };
    /**
     * Returns all system properties for the specified directory, and can also be used to check the
     * existence of a directory. The data returned does not include the files in the directory or any
     * subdirectories.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-directory-properties
     *
     * @param {DirectoryGetPropertiesOptions} [options] Options to Directory Get Properties operation.
     * @returns {Promise<DirectoryGetPropertiesResponse>} Response data for the Directory Get Properties operation.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_7;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getProperties({
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_7 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty directory. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param {DirectoryDeleteOptions} [options] Options to Directory Delete operation.
     * @returns {Promise<DirectoryDeleteResponse>} Response data for the Directory Delete operation.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_8;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.deleteMethod({
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_8 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_8.message
                        });
                        throw e_8;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Updates user defined metadata for the specified directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-metadata
     *
     * @param {Metadata} [metadata] If no metadata provided, all existing directory metadata will be removed
     * @param {DirectorySetMetadataOptions} [options] Options to Directory Set Metadata operation.
     * @returns {Promise<DirectorySetMetadataResponse>} Response data for the Directory Set Metadata operation.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_9;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.setMetadata({
                                abortSignal: options.abortSignal,
                                metadata: metadata,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_9 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_9.message
                        });
                        throw e_9;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListFilesAndDirectoriesSegmentResponse} objects
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of
     *                          the list of files and directories to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all files and directories remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param {DirectoryListFilesAndDirectoriesSegmentOptions} [options] Options to list files and directories operation.
     * @returns {AsyncIterableIterator<DirectoryListFilesAndDirectoriesSegmentResponse>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.iterateFilesAndDirectoriesSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function iterateFilesAndDirectoriesSegments_1() {
            var listFilesAndDirectoriesResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _a.label = 1;
                    case 1: return [4 /*yield*/, __await(this.listFilesAndDirectoriesSegment(marker, options))];
                    case 2:
                        listFilesAndDirectoriesResponse = _a.sent();
                        marker = listFilesAndDirectoriesResponse.continuationToken;
                        return [4 /*yield*/, __await(listFilesAndDirectoriesResponse)];
                    case 3: return [4 /*yield*/, __await.apply(void 0, [_a.sent()])];
                    case 4: return [4 /*yield*/, _a.sent()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for file and directory items
     *
     * @private
     * @param {DirectoryListFilesAndDirectoriesSegmentOptions} [options] Options to list files and directories operation.
     * @returns {AsyncIterableIterator<{ kind: "file" } & FileItem | { kind: "directory" } & DirectoryItem>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.listFilesAndDirectoriesItems = function (options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listFilesAndDirectoriesItems_1() {
            var marker, _a, _b, listFilesAndDirectoriesResponse, _i, _c, file, _d, _e, directory, e_10_1;
            var e_10, _f;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _g.label = 1;
                    case 1:
                        _g.trys.push([1, 15, 16, 21]);
                        _a = __asyncValues(this.iterateFilesAndDirectoriesSegments(marker, options));
                        _g.label = 2;
                    case 2: return [4 /*yield*/, __await(_a.next())];
                    case 3:
                        if (!(_b = _g.sent(), !_b.done)) return [3 /*break*/, 14];
                        listFilesAndDirectoriesResponse = _b.value;
                        _i = 0, _c = listFilesAndDirectoriesResponse.segment.fileItems;
                        _g.label = 4;
                    case 4:
                        if (!(_i < _c.length)) return [3 /*break*/, 8];
                        file = _c[_i];
                        return [4 /*yield*/, __await(__assign({ kind: "file" }, file))];
                    case 5: return [4 /*yield*/, _g.sent()];
                    case 6:
                        _g.sent();
                        _g.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 4];
                    case 8:
                        _d = 0, _e = listFilesAndDirectoriesResponse.segment.directoryItems;
                        _g.label = 9;
                    case 9:
                        if (!(_d < _e.length)) return [3 /*break*/, 13];
                        directory = _e[_d];
                        return [4 /*yield*/, __await(__assign({ kind: "directory" }, directory))];
                    case 10: return [4 /*yield*/, _g.sent()];
                    case 11:
                        _g.sent();
                        _g.label = 12;
                    case 12:
                        _d++;
                        return [3 /*break*/, 9];
                    case 13: return [3 /*break*/, 2];
                    case 14: return [3 /*break*/, 21];
                    case 15:
                        e_10_1 = _g.sent();
                        e_10 = { error: e_10_1 };
                        return [3 /*break*/, 21];
                    case 16:
                        _g.trys.push([16, , 19, 20]);
                        if (!(_b && !_b.done && (_f = _a.return))) return [3 /*break*/, 18];
                        return [4 /*yield*/, __await(_f.call(_a))];
                    case 17:
                        _g.sent();
                        _g.label = 18;
                    case 18: return [3 /*break*/, 20];
                    case 19:
                        if (e_10) throw e_10.error;
                        return [7 /*endfinally*/];
                    case 20: return [7 /*endfinally*/];
                    case 21: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the files and directories
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the files and directories in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const entity of directoryClient.listFilesAndDirectories()) {
     *   if (entity.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.name}`);
     *   }
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = await directoryClient.listFilesAndDirectories();
     * let entity = await iter.next();
     * while (!entity.done) {
     *   if (entity.value.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.value.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.value.name}`);
     *   }
     *   entity = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ maxPageSize: 20 })) {
     *   for (const fileItem of response.segment.fileItems) {
     *     console.log(`${i++} - file\t: ${fileItem.name}`);
     *   }
     *   for (const dirItem of response.segment.directoryItems) {
     *     console.log(`${i++} - directory\t: ${dirItem.name}`);
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = directoryClient.listFilesAndDirectories().byPage({ maxPageSize: 3 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 3 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     *
     * // Gets next marker
     * let dirMarker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     * iterator = directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ continuationToken: dirMarker, maxPageSize: 4 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     * ```
     *
     * @param {DirectoryListFilesAndDirectoriesOptions} [options] Options to list files and directories operation.
     * @memberof ShareDirectoryClient
     * @returns {PagedAsyncIterableIterator<{ kind: "file" } & FileItem | { kind: "directory" } , DirectoryListFilesAndDirectoriesSegmentResponse>}
     * An asyncIterableIterator that supports paging.
     */
    ShareDirectoryClient.prototype.listFilesAndDirectories = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        // AsyncIterableIterator to iterate over files and directories
        var iter = this.listFilesAndDirectoriesItems(options);
        return _a = {
                /**
                 * @member {Promise} [next] The next method, part of the iteration protocol
                 */
                next: function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.iterateFilesAndDirectoriesSegments(settings.continuationToken, __assign({ maxResults: settings.maxPageSize }, options));
            },
            _a;
    };
    /**
     * Returns a list of files or directories under the specified share or directory. It lists the
     * contents only for a single level of the directory hierarchy.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-directories-and-files
     *
     * @param {string} [marker] A string value that identifies the portion of the list to be returned with the next list operation.
     * @param {DirectoryListFilesAndDirectoriesSegmentOptions} [options] Options to Directory List Files and Directories Segment operation.
     * @returns {Promise<DirectoryListFilesAndDirectoriesSegmentResponse>} Response data for the Directory List Files and Directories operation.
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.listFilesAndDirectoriesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_11;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-listFilesAndDirectoriesSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        if (options.prefix === "") {
                            options.prefix = undefined;
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.listFilesAndDirectoriesSegment(__assign(__assign({ marker: marker }, options), { spanOptions: spanOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_11 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_11.message
                        });
                        throw e_11;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListHandlesResponse}
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param {DirectoryListHandlesSegmentOptions} [options] Options to list handles operation.
     * @returns {AsyncIterableIterator<DirectoryListHandlesResponse>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.iterateHandleSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function iterateHandleSegments_1() {
            var listHandlesResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!!marker || marker === undefined)) return [3 /*break*/, 7];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, __await(this.listHandlesSegment(marker, options))];
                    case 2:
                        listHandlesResponse = _a.sent();
                        marker = listHandlesResponse.continuationToken;
                        return [4 /*yield*/, __await(listHandlesResponse)];
                    case 3: return [4 /*yield*/, __await.apply(void 0, [_a.sent()])];
                    case 4: return [4 /*yield*/, _a.sent()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @private
     * @param {DirectoryListHandlesSegmentOptions} [options] Options to list handles operation.
     * @returns {AsyncIterableIterator<HandleItem>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.listHandleItems = function (options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listHandleItems_1() {
            var marker, _a, _b, listHandlesResponse, _i, _c, handle, e_12_1;
            var e_12, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _e.trys.push([0, 9, 10, 15]);
                        _a = __asyncValues(this.iterateHandleSegments(marker, options));
                        _e.label = 1;
                    case 1: return [4 /*yield*/, __await(_a.next())];
                    case 2:
                        if (!(_b = _e.sent(), !_b.done)) return [3 /*break*/, 8];
                        listHandlesResponse = _b.value;
                        if (!listHandlesResponse.handleList) return [3 /*break*/, 7];
                        _i = 0, _c = listHandlesResponse.handleList;
                        _e.label = 3;
                    case 3:
                        if (!(_i < _c.length)) return [3 /*break*/, 7];
                        handle = _c[_i];
                        return [4 /*yield*/, __await(handle)];
                    case 4: return [4 /*yield*/, _e.sent()];
                    case 5:
                        _e.sent();
                        _e.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7: return [3 /*break*/, 1];
                    case 8: return [3 /*break*/, 15];
                    case 9:
                        e_12_1 = _e.sent();
                        e_12 = { error: e_12_1 };
                        return [3 /*break*/, 15];
                    case 10:
                        _e.trys.push([10, , 13, 14]);
                        if (!(_b && !_b.done && (_d = _a.return))) return [3 /*break*/, 12];
                        return [4 /*yield*/, __await(_d.call(_a))];
                    case 11:
                        _e.sent();
                        _e.label = 12;
                    case 12: return [3 /*break*/, 14];
                    case 13:
                        if (e_12) throw e_12.error;
                        return [7 /*endfinally*/];
                    case 14: return [7 /*endfinally*/];
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * for await (const handle of iter) {
     *   console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = await dirClient.listHandles();
     * let handleItem = await iter.next();
     * while (!handleItem.done) {
     *   console.log(`Handle ${i++}: ${handleItem.value.path}, opened time ${handleItem.value.openTime}, clientIp ${handleItem.value.clientIp}`);
     *   handleItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of dirClient.listHandles({ recursive: true }).byPage({ maxPageSize: 20 })) {
     *   if (response.handleList) {
     *     for (const handle of response.handleList) {
     *       console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = dirClient.listHandles().byPage({ maxPageSize: 2 });
     * let response = await iterator.next();
     *
     * // Prints 2 handles
     * if (response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.value.continuationToken;
     *
     * // Passing next marker as continuationToken
     * console.log(`    continuation`);
     * iterator = dirClient.listHandles().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = await iterator.next();
     *
     * // Prints 2 more handles assuming you have more than four directory/files opened
     * if (!response.done && response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     * ```
     *
     * @param {DirectoryListHandlesOptions} [options] Options to list handles operation.
     * @memberof ShareDirectoryClient
     * @returns {PagedAsyncIterableIterator<HandleItem, DirectoryListHandlesResponse>}
     * An asyncIterableIterator that supports paging.
     */
    ShareDirectoryClient.prototype.listHandles = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        // an AsyncIterableIterator to iterate over handles
        var iter = this.listHandleItems(options);
        return _a = {
                /**
                 * @member {Promise} [next] The next method, part of the iteration protocol
                 */
                next: function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.iterateHandleSegments(settings.continuationToken, __assign({ maxResults: settings.maxPageSize }, options));
            },
            _a;
    };
    /**
     * Lists handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param {string} [marker] Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param {DirectoryListHandlesSegmentOptions} [options={}]
     * @returns {Promise<DirectoryListHandlesResponse>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.listHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, e_13;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-listHandlesSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.listHandles(__assign(__assign({ marker: marker }, options), { spanOptions: spanOptions }))];
                    case 2:
                        response = _b.sent();
                        // TODO: Protocol layer issue that when handle list is in returned XML
                        // response.handleList is an empty string
                        if (response.handleList === "") {
                            response.handleList = undefined;
                        }
                        return [2 /*return*/, response];
                    case 3:
                        e_13 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_13.message
                        });
                        throw e_13;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {string} [marker] Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param {DirectoryForceCloseHandlesSegmentOptions} [options={}]
     * @returns {Promise<DirectoryForceCloseHandlesResponse>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.forceCloseHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, rawResponse, response, e_14;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-forceCloseHandlesSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.forceCloseHandles("*", __assign(__assign({ marker: marker }, options), { spanOptions: spanOptions }))];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
                        response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
                        return [2 /*return*/, response];
                    case 3:
                        e_14 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_14.message
                        });
                        throw e_14;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {DirectoryForceCloseHandlesSegmentOptions} [options={}]
     * @returns {Promise<CloseHandlesInfo>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.forceCloseAllHandles = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, handlesClosed, numberOfHandlesFailedToClose, marker, response, e_15;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-forceCloseAllHandles", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        handlesClosed = 0;
                        numberOfHandlesFailedToClose = 0;
                        marker = "";
                        _b.label = 2;
                    case 2: return [4 /*yield*/, this.forceCloseHandlesSegment(marker, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 3:
                        response = _b.sent();
                        marker = response.marker;
                        response.closedHandlesCount && (handlesClosed += response.closedHandlesCount);
                        response.closeFailureCount && (numberOfHandlesFailedToClose += response.closeFailureCount);
                        _b.label = 4;
                    case 4:
                        if (marker) return [3 /*break*/, 2];
                        _b.label = 5;
                    case 5: return [2 /*return*/, { closedHandlesCount: handlesClosed, closeFailureCount: numberOfHandlesFailedToClose }];
                    case 6:
                        e_15 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_15.message
                        });
                        throw e_15;
                    case 7:
                        span.end();
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close a specific handle for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {Aborter} aborter Create a new Aborter instance with Aborter.none or Aborter.timeout(),
     *                          goto documents of Aborter for more examples about request cancellation
     * @param {string} handleId Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseHandlesSegment() to close all handles.
     * @param {DirectoryForceCloseHandlesOptions} [options={}]
     * @returns {Promise<DirectoryForceCloseHandlesResponse>}
     * @memberof ShareDirectoryClient
     */
    ShareDirectoryClient.prototype.forceCloseHandle = function (handleId, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, rawResponse, response, e_16;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareDirectoryClient-forceCloseHandle", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (handleId === "*") {
                            throw new RangeError("Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.");
                        }
                        return [4 /*yield*/, this.context.forceCloseHandles(handleId, {
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        rawResponse = _b.sent();
                        response = rawResponse;
                        response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
                        response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
                        return [2 /*return*/, response];
                    case 3:
                        e_16 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_16.message
                        });
                        throw e_16;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return ShareDirectoryClient;
}(StorageClient));
export { ShareDirectoryClient };
//# sourceMappingURL=ShareDirectoryClient.js.map
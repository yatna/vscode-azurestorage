// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __assign, __awaiter, __extends, __generator } from "tslib";
import { isNode } from "@azure/core-http";
import { CanonicalCode } from "@opentelemetry/types";
import { Share } from "./generated/src/operations";
import { newPipeline, Pipeline } from "./Pipeline";
import { StorageClient } from "./StorageClient";
import { URLConstants } from "./utils/constants";
import { appendToURLPath, setURLParameter, truncatedISO8061Date, extractConnectionStringParts, getShareNameAndPathFromUrl } from "./utils/utils.common";
import { ShareDirectoryClient } from "./ShareDirectoryClient";
import { Credential } from "./credentials/Credential";
import { StorageSharedKeyCredential } from "./credentials/StorageSharedKeyCredential";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { createSpan } from "./utils/tracing";
/**
 * A ShareClient represents a URL to the Azure Storage share allowing you to manipulate its directories and files.
 *
 * @export
 * @class ShareClient
 */
var ShareClient = /** @class */ (function (_super) {
    __extends(ShareClient, _super);
    function ShareClient(urlOrConnectionString, credentialOrPipelineOrShareName, options) {
        var _this = this;
        var pipeline;
        var url;
        if (credentialOrPipelineOrShareName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrShareName;
        }
        else if (credentialOrPipelineOrShareName instanceof Credential) {
            // (url: string, credential?: Credential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            pipeline = newPipeline(credentialOrPipelineOrShareName, options);
        }
        else if (!credentialOrPipelineOrShareName &&
            typeof credentialOrPipelineOrShareName !== "string") {
            // (url: string, credential?: Credential, options?: StoragePipelineOptions)
            // The second parameter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrShareName &&
            typeof credentialOrPipelineOrShareName === "string") {
            // (connectionString: string, name: string, options?: StoragePipelineOptions)
            var extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            var name_1 = credentialOrPipelineOrShareName;
            if (extractedCreds.kind === "AccountConnString") {
                if (isNode) {
                    var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(extractedCreds.url, name_1);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
                else {
                    throw new Error("Account connection string is only supported in Node.js environment");
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                url = appendToURLPath(extractedCreds.url, name_1) + "?" + extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for name parameter");
        }
        _this = _super.call(this, url, pipeline) || this;
        _this._name = getShareNameAndPathFromUrl(_this.url).shareName;
        _this.context = new Share(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ShareClient.prototype, "name", {
        /**
         * The name of the share
         *
         * @type {string}
         * @memberof ShareClient
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new ShareClient object identical to the source but with the specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base share.
     *
     * @param {string} snapshot The snapshot timestamp.
     * @returns {ShareClient} A new ShareClient object identical to the source but with the specified snapshot timestamp
     * @memberof ShareClient
     */
    ShareClient.prototype.withSnapshot = function (snapshot) {
        return new ShareClient(setURLParameter(this.url, URLConstants.Parameters.SHARE_SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    };
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, the operation fails.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param {ShareCreateOptions} [options] Options to Share Create operation.
     * @returns {Promise<ShareCreateResponse>} Response data for the Share Create operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.create(__assign(__assign({}, options), { spanOptions: spanOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a {@link ShareDirectoryClient} object.
     *
     * @param directoryName A directory name
     * @returns {ShareDirectoryClient} The ShareDirectoryClient object for the given directory name.
     * @memberof ShareClient
     */
    ShareClient.prototype.getDirectoryClient = function (directoryName) {
        return new ShareDirectoryClient(appendToURLPath(this.url, encodeURIComponent(directoryName)), this.pipeline);
    };
    Object.defineProperty(ShareClient.prototype, "rootDirectoryClient", {
        /**
         * Gets the directory client for the root directory of this share.
         * Note that the root directory always exists and cannot be deleted.
         *
         * @readonly
         * @type {ShareDirectoryClient} A new ShareDirectoryClient object for the root directory.
         * @memberof ShareClient
         */
        get: function () {
            return this.getDirectoryClient("");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new subdirectory under this share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param {string} directoryName
     * @param {DirectoryCreateOptions} [options] Options to Directory Create operation.
     * @returns {Promise<{ directoryClient: ShareDirectoryClient, directoryCreateResponse: DirectoryCreateResponse }>} Directory creation response data and the corresponding directory client.
     * @memberof ShareClient
     */
    ShareClient.prototype.createDirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, directoryClient, directoryCreateResponse, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createDirectory", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.create(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        directoryCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                directoryClient: directoryClient,
                                directoryCreateResponse: directoryCreateResponse
                            }];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes the specified empty sub directory under this share.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param {string} directoryName
     * @param {DirectoryDeleteOptions} [options] Options to Directory Delete operation.
     * @returns {Promise<DirectoryDeleteResponse>} Directory deletion response data.
     * @memberof ShareClient
     */
    ShareClient.prototype.deleteDirectory = function (directoryName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, directoryClient, e_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-deleteDirectory", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.getDirectoryClient(directoryName);
                        return [4 /*yield*/, directoryClient.delete(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a new file or replaces a file under the root directory of this share.
     * Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param {string} fileName
     * @param {number} size Specifies the maximum size in bytes for the file, up to 1 TB.
     * @param {FileCreateOptions} [options] Options to File Create operation.
     * @returns {Promise<{ fileClient: ShareFileClient, fileCreateResponse: FileCreateResponse }>} File creation response data and the corresponding file client.
     * @memberof ShareClient
     */
    ShareClient.prototype.createFile = function (fileName, size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, directoryClient, fileClient, fileCreateResponse, e_4;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.rootDirectoryClient;
                        fileClient = directoryClient.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.create(size, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        fileCreateResponse = _b.sent();
                        return [2 /*return*/, {
                                fileClient: fileClient,
                                fileCreateResponse: fileCreateResponse
                            }];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes a file under the root directory of this share from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code `SharingViolation`
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400
     * (`InvalidQueryParameterValue`)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param {string} directoryName
     * @param {string} fileName
     * @param {FileDeleteOptions} [options] Options to File Delete operation.
     * @returns Promise<FileDeleteResponse> File Delete response data.
     * @memberof ShareClient
     */
    ShareClient.prototype.deleteFile = function (fileName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, directoryClient, fileClient, e_5;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-deleteFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        directoryClient = this.rootDirectoryClient;
                        fileClient = directoryClient.getFileClient(fileName);
                        return [4 /*yield*/, fileClient.delete(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata and system properties for the specified
     * share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-properties
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listShares` method of {@link ShareServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @returns {Promise<ShareGetPropertiesResponse>} Response data for the Share Get Properties operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_6;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getProperties({
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Marks the specified share for deletion. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param {ShareDeleteMethodOptions} [options] Options to Share Delete operation.
     * @returns {Promise<ShareDeleteResponse>} Response data for the Share Delete operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_7;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.deleteMethod(__assign(__assign({}, options), { spanOptions: spanOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_7 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets one or more user-defined name-value pairs for the specified share.
     *
     * If no option provided, or no metadata defined in the option parameter, the share
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-metadata
     *
     * @param {Metadata} [metadata] If no metadata provided, all existing directory metadata will be removed.
     * @param {ShareSetMetadataOptions} [option] Options to Share Set Metadata operation.
     * @returns {Promise<ShareSetMetadataResponse>} Response data for the Share Set Metadata operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_8;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.setMetadata({
                                abortSignal: options.abortSignal,
                                metadata: metadata,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_8 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_8.message
                        });
                        throw e_8;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the permissions for the specified share. The permissions indicate
     * whether share data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potential lost precision when parsing start and expiry string.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-acl
     *
     * @param {ShareGetAccessPolicyOptions} [option] Options to Share Get Access Policy operation.
     * @returns {Promise<ShareGetAccessPolicyResponse>} Response data for the Share Get Access Policy operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.getAccessPolicy = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, res, _i, response_1, identifier, e_9;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getAccessPolicy({
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        response = _b.sent();
                        res = {
                            _response: response._response,
                            date: response.date,
                            etag: response.etag,
                            lastModified: response.lastModified,
                            requestId: response.requestId,
                            signedIdentifiers: [],
                            version: response.version
                        };
                        for (_i = 0, response_1 = response; _i < response_1.length; _i++) {
                            identifier = response_1[_i];
                            res.signedIdentifiers.push({
                                accessPolicy: {
                                    expiresOn: new Date(identifier.accessPolicy.expiresOn),
                                    permissions: identifier.accessPolicy.permissions,
                                    startsOn: new Date(identifier.accessPolicy.startsOn)
                                },
                                id: identifier.id
                            });
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_9 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_9.message
                        });
                        throw e_9;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets the permissions for the specified share. The permissions indicate
     * whether directories or files in a share may be accessed publicly.
     *
     * When you set permissions for a share, the existing permissions are replaced.
     * If no shareAcl provided, the existing share ACL will be
     * removed.
     *
     * When you establish a stored access policy on a share, it may take up to 30 seconds to take effect.
     * During this interval, a shared access signature that is associated with the stored access policy will
     * fail with status code 403 (Forbidden), until the access policy becomes active.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-acl
     *
     * @param {SignedIdentifier[]} [shareAcl] Array of signed identifiers, each having a unique Id and details of access policy.
     * @param {ShareSetAccessPolicyOptions} [option] Options to Share Set Access Policy operation.
     * @returns {Promise<ShareSetAccessPolicyResponse>} Response data for the Share Set Access Policy operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.setAccessPolicy = function (shareAcl, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, acl, _i, _b, identifier, e_10;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = createSpan("ShareClient-setAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, 4, 5]);
                        acl = [];
                        for (_i = 0, _b = shareAcl || []; _i < _b.length; _i++) {
                            identifier = _b[_i];
                            acl.push({
                                accessPolicy: {
                                    expiresOn: truncatedISO8061Date(identifier.accessPolicy.expiresOn),
                                    permissions: identifier.accessPolicy.permissions,
                                    startsOn: truncatedISO8061Date(identifier.accessPolicy.startsOn)
                                },
                                id: identifier.id
                            });
                        }
                        return [4 /*yield*/, this.context.setAccessPolicy({
                                abortSignal: options.abortSignal,
                                shareAcl: acl,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _c.sent()];
                    case 3:
                        e_10 = _c.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_10.message
                        });
                        throw e_10;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a read-only snapshot of a share.
     *
     * @param {ShareCreateSnapshotOptions} [options={}] Options to Share Create Snapshot operation.
     * @returns {Promise<ShareCreateSnapshotResponse>} Response data for the Share Create Snapshot operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.createSnapshot = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_11;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createSnapshot", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.createSnapshot(__assign(__assign({ abortSignal: options.abortSignal }, options), { spanOptions: spanOptions }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_11 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_11.message
                        });
                        throw e_11;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets quota for the specified share.
     *
     * @param {number} quotaInGB Specifies the maximum size of the share in gigabytes
     * @param {ShareSetQuotaOptions} [option] Options to Share Set Quota operation.
     * @returns {Promise<ShareSetQuotaResponse>} Response data for the Share Get Quota operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.setQuota = function (quotaInGB, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_12;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-setQuota", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (quotaInGB <= 0 || quotaInGB > 5120) {
                            throw new RangeError("Share quota must be greater than 0, and less than or equal to 5Tib (5120GB)");
                        }
                        return [4 /*yield*/, this.context.setQuota({
                                abortSignal: options.abortSignal,
                                quota: quotaInGB,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_12 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_12.message
                        });
                        throw e_12;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves statistics related to the share.
     *
     * @param {ShareGetStatisticsOptions} [option] Options to Share Get Statistics operation.
     * @returns {Promise<ShareGetStatisticsResponse>} Response data for the Share Get Statistics operation.
     * @memberof ShareClient
     */
    ShareClient.prototype.getStatistics = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, GBBytes, e_13;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getStatistics", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getStatistics({
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        response = _b.sent();
                        GBBytes = 1024 * 1024 * 1024;
                        return [2 /*return*/, __assign(__assign({}, response), { shareUsage: Math.ceil(response.shareUsageBytes / GBBytes) })];
                    case 3:
                        e_13 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_13.message
                        });
                        throw e_13;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a file permission (a security descriptor) at the share level.
     * The created security descriptor can be used for the files/directories in the share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-permission
     *
     * @param {ShareCreatePermissionOptions} [options] Options to Share Create Permission operation.
     * @param filePermission File permission described in the SDDL
     */
    ShareClient.prototype.createPermission = function (filePermission, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_14;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-createPermission", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.createPermission({
                                permission: filePermission
                            }, {
                                abortSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_14 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_14.message
                        });
                        throw e_14;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the Security Descriptor Definition Language (SDDL) for a given file permission key
     * which indicates a security descriptor.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-permission
     *
     * @param {ShareGetPermissionOptions} [options] Options to Share Create Permission operation.
     * @param filePermissionKey File permission key which indicates the security descriptor of the permission.
     */
    ShareClient.prototype.getPermission = function (filePermissionKey, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_15;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareClient-getPermission", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getPermission(filePermissionKey, {
                                aborterSignal: options.abortSignal,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_15 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_15.message
                        });
                        throw e_15;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return ShareClient;
}(StorageClient));
export { ShareClient };
//# sourceMappingURL=ShareClient.js.map
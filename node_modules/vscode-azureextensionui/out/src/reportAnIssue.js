"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const vscode = require("vscode");
const getPackageInfo_1 = require("./getPackageInfo");
const localize_1 = require("./localize");
const openUrl_1 = require("./utils/openUrl");
// Some browsers don't have very long URLs
// 2000 seems a reasonable number for most browsers,
// see https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers
exports.maxUrlLength = 2000;
/**
 * Used to open the browser to the "New Issue" page on GitHub with relevant context pre-filled in the issue body
 */
function reportAnIssue(actionId, parsedError, issueProperties) {
    return __awaiter(this, void 0, void 0, function* () {
        const link = yield getReportAnIssueLink(actionId, parsedError, issueProperties);
        yield openUrl_1.openUrl(link);
    });
}
exports.reportAnIssue = reportAnIssue;
function getReportAnIssueLink(actionId, parsedError, issueProperties) {
    return __awaiter(this, void 0, void 0, function* () {
        // tslint:disable-next-line: strict-boolean-expressions
        const stack = (parsedError.stack || '').replace(/\r\n/g, '\n');
        return yield createNewIssueLink(actionId, parsedError, stack, issueProperties);
    });
}
exports.getReportAnIssueLink = getReportAnIssueLink;
function createNewIssueLink(actionId, parsedError, stack, issueProperties) {
    return __awaiter(this, void 0, void 0, function* () {
        const { extensionVersion } = getPackageInfo_1.getPackageInfo();
        let body = `
<!-- ${localize_1.localize('reportIssue_removePrivateInfo', "IMPORTANT: Please be sure to remove any private information before submitting.")} -->

${localize_1.localize('reportIssue_isItConsistent', "Does this occur consistently? <!-- TODO: Type Yes or No -->")}
Repro steps:
<!-- ${localize_1.localize('reportIssue_enterReproSteps', "TODO: Share the steps needed to reliably reproduce the problem. Please include actual and expected results.")} -->

1.
2.

Action: ${actionId}
Error type: ${parsedError.errorType}
Error Message: ${parsedError.message}

Version: ${extensionVersion}
OS: ${process.platform}
OS Release: ${os.release()}
Product: ${vscode.env.appName}
Product Version: ${vscode.version}
Language: ${vscode.env.language}`;
        // Add stack and any custom issue properties as individual details
        const details = Object.assign({}, stack ? { 'Call Stack': stack } : {}, issueProperties); // Don't localize call stack
        for (const propName of Object.getOwnPropertyNames(details)) {
            const value = details[propName];
            body += createBodyDetail(propName, String(value));
        }
        const simpleLink = createNewIssueLinkFromBody(body);
        if (simpleLink.length <= exports.maxUrlLength) {
            return simpleLink;
        }
        // If it's too long, paste it to the clipboard
        yield vscode.env.clipboard.writeText(body);
        return createNewIssueLinkFromBody(localize_1.localize('pasteIssue', "The issue text was copied to the clipboard.  Please paste it into this window."));
    });
}
function createNewIssueLinkFromBody(issueBody) {
    const { extensionName, bugsUrl } = getPackageInfo_1.getPackageInfo();
    const baseUrl = bugsUrl || `https://github.com/Microsoft/${extensionName}/issues`;
    return `${baseUrl}/new?body=${encodeURIComponent(issueBody)}`;
}
function createBodyDetail(detailName, detail) {
    return `

<details>
<summary>${detailName}</summary>

\`\`\`
${detail}
\`\`\`

</details>
`;
}
//# sourceMappingURL=reportAnIssue.js.map
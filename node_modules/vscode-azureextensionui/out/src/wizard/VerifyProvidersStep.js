"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const azure_arm_resource_1 = require("azure-arm-resource");
const createAzureClient_1 = require("../createAzureClient");
const localize_1 = require("../localize");
const parseError_1 = require("../parseError");
const delay_1 = require("../utils/delay");
const AzureWizardExecuteStep_1 = require("./AzureWizardExecuteStep");
class VerifyProvidersStep extends AzureWizardExecuteStep_1.AzureWizardExecuteStep {
    constructor(providers) {
        super();
        this.priority = 90;
        this._providers = providers;
    }
    execute(context, progress) {
        return __awaiter(this, void 0, void 0, function* () {
            progress.report({ message: localize_1.localize('registeringProviders', 'Registering Providers...') });
            const client = createAzureClient_1.createAzureClient(context, azure_arm_resource_1.ResourceManagementClient);
            yield Promise.all(this._providers.map((providerName) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                try {
                    let provider = yield client.providers.get(providerName);
                    if (((_a = provider.registrationState) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== 'registered') {
                        yield client.providers.register(providerName);
                        // The register call doesn't actually wait for register to finish, so we will poll for state
                        // Also, creating a resource seems to work even if it's in the 'registering' state (which can last several minutes), so we won't wait longer than 30 seconds
                        const maxTime = Date.now() + 30 * 1000;
                        do {
                            yield delay_1.delay(2 * 1000);
                            provider = yield client.providers.get(providerName);
                        } while (((_b = provider.registrationState) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === 'registering' && Date.now() < maxTime);
                    }
                }
                catch (error) {
                    // ignore and continue with wizard. An error here would likely be confusing and un-actionable
                    context.telemetry.properties.providerError = parseError_1.parseError(error).message;
                }
            })));
        });
    }
    shouldExecute(_context) {
        return true;
    }
}
exports.VerifyProvidersStep = VerifyProvidersStep;
//# sourceMappingURL=VerifyProvidersStep.js.map
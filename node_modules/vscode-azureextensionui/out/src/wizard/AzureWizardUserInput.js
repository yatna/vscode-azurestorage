"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = require("vscode");
const errors_1 = require("../errors");
/**
 * Provides more advanced versions of vscode.window.showQuickPick and vscode.window.showInputBox for use in the AzureWizard
 */
class AzureWizardUserInput {
    constructor(wizard) {
        this.isPrompting = false;
        this._wizard = wizard;
    }
    get showBackButton() {
        return this._wizard.currentStep > 1;
    }
    get _showTitle() {
        return this._wizard.totalSteps > 1;
    }
    showQuickPick(picks, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const disposables = [];
            try {
                const quickPick = vscode_1.window.createQuickPick();
                disposables.push(quickPick);
                if (this._showTitle) {
                    quickPick.title = this._wizard.title;
                    if (!this._wizard.hideStepCount && this._wizard.title) {
                        quickPick.step = this._wizard.currentStep;
                        quickPick.totalSteps = this._wizard.totalSteps;
                    }
                }
                quickPick.buttons = this.showBackButton ? [vscode_1.QuickInputButtons.Back] : [];
                // Copy settings that are common between options and quickPick
                quickPick.placeholder = options.loadingPlaceHolder || options.placeHolder;
                quickPick.ignoreFocusOut = !!options.ignoreFocusOut;
                quickPick.matchOnDescription = !!options.matchOnDescription;
                quickPick.matchOnDetail = !!options.matchOnDetail;
                quickPick.canSelectMany = !!options.canPickMany;
                return yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    disposables.push(quickPick.onDidAccept(() => {
                        if (options.canPickMany) {
                            resolve(Array.from(quickPick.selectedItems));
                        }
                        else {
                            resolve(quickPick.selectedItems[0]);
                        }
                    }), quickPick.onDidTriggerButton(_btn => {
                        // Only back button is supported for now
                        reject(new errors_1.GoBackError());
                    }), quickPick.onDidHide(() => {
                        reject(new errors_1.UserCancelledError());
                    }));
                    // Show progress bar while loading quick picks
                    quickPick.busy = true;
                    quickPick.enabled = false;
                    quickPick.show();
                    this.isPrompting = true;
                    try {
                        quickPick.items = yield Promise.resolve(picks);
                        if (options.canPickMany && options.isPickSelected) {
                            // tslint:disable-next-line: no-non-null-assertion
                            quickPick.selectedItems = quickPick.items.filter(p => options.isPickSelected(p));
                        }
                        quickPick.placeholder = options.placeHolder;
                        quickPick.busy = false;
                        quickPick.enabled = true;
                    }
                    catch (err) {
                        reject(err);
                    }
                }));
            }
            finally {
                this.isPrompting = false;
                disposables.forEach(d => { d.dispose(); });
            }
        });
    }
    showInputBox(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const disposables = [];
            try {
                const inputBox = vscode_1.window.createInputBox();
                disposables.push(inputBox);
                if (this._showTitle) {
                    inputBox.title = this._wizard.title;
                    if (!this._wizard.hideStepCount && this._wizard.title) {
                        inputBox.step = this._wizard.currentStep;
                        inputBox.totalSteps = this._wizard.totalSteps;
                    }
                }
                inputBox.buttons = this.showBackButton ? [vscode_1.QuickInputButtons.Back] : [];
                if (!inputBox.password) {
                    // tslint:disable-next-line: strict-boolean-expressions
                    inputBox.value = this._wizard.getCachedInputBoxValue() || options.value || '';
                }
                // Copy settings that are common between options and inputBox
                inputBox.ignoreFocusOut = !!options.ignoreFocusOut;
                inputBox.password = !!options.password;
                inputBox.placeholder = options.placeHolder;
                inputBox.prompt = options.prompt;
                let latestValidation = options.validateInput ? Promise.resolve(options.validateInput(inputBox.value)) : Promise.resolve('');
                return yield new Promise((resolve, reject) => {
                    disposables.push(inputBox.onDidChangeValue((text) => __awaiter(this, void 0, void 0, function* () {
                        if (options.validateInput) {
                            const validation = Promise.resolve(options.validateInput(text));
                            latestValidation = validation;
                            const message = yield validation;
                            if (validation === latestValidation) {
                                // tslint:disable-next-line: strict-boolean-expressions
                                inputBox.validationMessage = message || '';
                            }
                        }
                    })), inputBox.onDidAccept(() => __awaiter(this, void 0, void 0, function* () {
                        // Run final validation and resolve if value passes
                        inputBox.enabled = false;
                        inputBox.busy = true;
                        const message = yield latestValidation;
                        if (!message) {
                            resolve(inputBox.value);
                        }
                        else {
                            inputBox.validationMessage = message;
                        }
                        inputBox.enabled = true;
                        inputBox.busy = false;
                    })), inputBox.onDidTriggerButton(_btn => {
                        // Only back button is supported for now
                        reject(new errors_1.GoBackError());
                    }), inputBox.onDidHide(() => {
                        reject(new errors_1.UserCancelledError());
                    }));
                    inputBox.show();
                    this.isPrompting = true;
                });
            }
            finally {
                this.isPrompting = false;
                disposables.forEach(d => { d.dispose(); });
            }
        });
    }
}
exports.AzureWizardUserInput = AzureWizardUserInput;
//# sourceMappingURL=AzureWizardUserInput.js.map
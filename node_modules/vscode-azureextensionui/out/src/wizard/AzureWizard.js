"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const vscode = require("vscode");
const errors_1 = require("../errors");
const extensionVariables_1 = require("../extensionVariables");
const parseError_1 = require("../parseError");
const AzureWizardUserInput_1 = require("./AzureWizardUserInput");
class AzureWizard {
    constructor(context, options) {
        this._finishedPromptSteps = [];
        this._cachedInputBoxValues = {};
        // reverse steps to make it easier to use push/pop
        // tslint:disable-next-line: strict-boolean-expressions
        this._promptSteps = (options.promptSteps || []).reverse();
        this._promptSteps.forEach(s => { s.effectiveTitle = options.title; });
        // tslint:disable-next-line: strict-boolean-expressions
        this._executeSteps = options.executeSteps || [];
        this._context = context;
        this._wizardHideStepCount = options.hideStepCount;
    }
    getCachedInputBoxValue() {
        return this._currentStepName ? this._cachedInputBoxValues[this._currentStepName] : undefined;
    }
    get hideStepCount() {
        return !!(this._wizardHideStepCount || this._stepHideStepCount);
    }
    get currentStep() {
        return this._finishedPromptSteps.filter(s => s.prompted).length + 1;
    }
    get totalSteps() {
        return this._finishedPromptSteps.filter(s => s.prompted).length + this._promptSteps.filter(s => s.shouldPrompt(this._context)).length + 1;
    }
    prompt() {
        return __awaiter(this, void 0, void 0, function* () {
            const wizardUi = new AzureWizardUserInput_1.AzureWizardUserInput(this);
            extensionVariables_1.ext.ui.wizardUserInput = wizardUi;
            try {
                let step = this._promptSteps.pop();
                while (step) {
                    step.reset();
                    this._context.telemetry.properties.lastStepAttempted = `prompt-${step.constructor.name}`;
                    this.title = step.effectiveTitle;
                    this._stepHideStepCount = step.hideStepCount;
                    if (step.shouldPrompt(this._context)) {
                        step.propertiesBeforePrompt = Object.keys(this._context).filter(k => !util_1.isNullOrUndefined(this._context[k]));
                        const disposable = extensionVariables_1.ext.ui.onDidFinishPrompt((result) => {
                            // tslint:disable-next-line: no-non-null-assertion
                            step.prompted = true;
                            if (typeof result === 'string' && this._currentStepName && !(step === null || step === void 0 ? void 0 : step.supportsDuplicateSteps)) {
                                this._cachedInputBoxValues[this._currentStepName] = result;
                            }
                        });
                        try {
                            this._currentStepName = step.constructor.name;
                            yield step.prompt(this._context);
                        }
                        catch (err) {
                            if (parseError_1.parseError(err).errorType === 'GoBackError') { // Use `errorType` instead of `instanceof` so that tests can also hit this case
                                step = this.goBack(step);
                                continue;
                            }
                            else {
                                throw err;
                            }
                        }
                        finally {
                            this._currentStepName = undefined;
                            disposable.dispose();
                        }
                    }
                    if (step.getSubWizard) {
                        const subWizard = yield step.getSubWizard(this._context);
                        if (subWizard) {
                            this.addSubWizard(step, subWizard);
                        }
                    }
                    this._finishedPromptSteps.push(step);
                    step = this._promptSteps.pop();
                }
            }
            finally {
                if (extensionVariables_1.ext.ui.wizardUserInput === wizardUi) { // don't reset if another wizard has already started
                    extensionVariables_1.ext.ui.wizardUserInput = undefined;
                }
            }
        });
    }
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            yield vscode.window.withProgress({ location: vscode.ProgressLocation.Notification }, (progress) => __awaiter(this, void 0, void 0, function* () {
                let currentStep = 1;
                const steps = this._executeSteps.sort((a, b) => b.priority - a.priority);
                const internalProgress = {
                    report: (value) => {
                        if (value.message) {
                            const totalSteps = currentStep + steps.filter(s => s.shouldExecute(this._context)).length;
                            if (totalSteps > 1) {
                                value.message += ` (${currentStep}/${totalSteps})`;
                            }
                        }
                        progress.report(value);
                    }
                };
                let step = steps.pop();
                while (step) {
                    if (step.shouldExecute(this._context)) {
                        this._context.telemetry.properties.lastStepAttempted = `execute-${step.constructor.name}`;
                        yield step.execute(this._context, internalProgress);
                        currentStep += 1;
                    }
                    step = steps.pop();
                }
            }));
        });
    }
    goBack(currentStep) {
        let step = currentStep;
        do {
            this._promptSteps.push(step);
            step = this._finishedPromptSteps.pop();
            if (!step) {
                throw new errors_1.GoBackError();
            }
        } while (!step.prompted);
        if (step.hasSubWizard) {
            removeFromEnd(this._promptSteps, step.numSubPromptSteps);
            removeFromEnd(this._executeSteps, step.numSubExecuteSteps);
        }
        for (const key of Object.keys(this._context)) {
            if (!step.propertiesBeforePrompt.find(p => p === key)) {
                this._context[key] = undefined;
            }
        }
        return step;
    }
    addSubWizard(step, subWizard) {
        step.hasSubWizard = true;
        if (subWizard.promptSteps) {
            subWizard.promptSteps = subWizard.promptSteps.filter(s1 => {
                return s1.supportsDuplicateSteps || !this._finishedPromptSteps.concat(this._promptSteps).some(s2 => s1.constructor.name === s2.constructor.name);
            });
            this._promptSteps.push(...subWizard.promptSteps.reverse());
            step.numSubPromptSteps = subWizard.promptSteps.length;
            subWizard.promptSteps.forEach(s => { s.effectiveTitle = subWizard.title || step.effectiveTitle; });
        }
        if (subWizard.executeSteps) {
            this._executeSteps.push(...subWizard.executeSteps);
            step.numSubExecuteSteps = subWizard.executeSteps.length;
        }
    }
}
exports.AzureWizard = AzureWizard;
function removeFromEnd(array, n) {
    array.splice(n * -1, n);
}
//# sourceMappingURL=AzureWizard.js.map
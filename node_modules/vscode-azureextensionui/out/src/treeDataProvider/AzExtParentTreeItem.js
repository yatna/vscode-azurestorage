"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const vscode_1 = require("vscode");
const errors_1 = require("../errors");
const extensionVariables_1 = require("../extensionVariables");
const localize_1 = require("../localize");
const randomUtils_1 = require("../utils/randomUtils");
const AzExtTreeItem_1 = require("./AzExtTreeItem");
const GenericTreeItem_1 = require("./GenericTreeItem");
const IconPath_1 = require("./IconPath");
const InternalInterfaces_1 = require("./InternalInterfaces");
const runWithLoadingNotification_1 = require("./runWithLoadingNotification");
const treeConstants_1 = require("./treeConstants");
// tslint:disable: max-classes-per-file
class AzExtParentTreeItem extends AzExtTreeItem_1.AzExtTreeItem {
    constructor() {
        super(...arguments);
        //#endregion
        this.collapsibleState = vscode_1.TreeItemCollapsibleState.Collapsed;
        this._isAzExtParentTreeItem = true;
        this._cachedChildren = [];
        this._creatingTreeItems = [];
        this._clearCache = true;
    }
    getCachedChildren(context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._clearCache) {
                this._initChildrenTask = this.loadMoreChildren(context);
            }
            if (this._initChildrenTask) {
                yield this._initChildrenTask;
            }
            return this._cachedChildren;
        });
    }
    get creatingTreeItems() {
        return this._creatingTreeItems;
    }
    //#endregion
    clearCache() {
        this._clearCache = true;
    }
    createChild(context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.createChildImpl) {
                context.telemetry.properties.advancedCreation = String(!!context.advancedCreation);
                let creatingTreeItem;
                try {
                    const newTreeItem = yield this.createChildImpl(Object.assign(context, {
                        showCreatingTreeItem: (label) => {
                            creatingTreeItem = new GenericTreeItem_1.GenericTreeItem(this, {
                                label: localize_1.localize('creatingLabel', 'Creating {0}...', label),
                                contextValue: `azureextensionui.creating${label}`,
                                iconPath: IconPath_1.getThemedIconPath('Loading')
                            });
                            this._creatingTreeItems.push(creatingTreeItem);
                            this.treeDataProvider.refreshUIOnly(this);
                        }
                    }));
                    this.addChildToCache(newTreeItem);
                    this.treeDataProvider._onTreeItemCreateEmitter.fire(newTreeItem);
                    return newTreeItem;
                }
                finally {
                    if (creatingTreeItem) {
                        this._creatingTreeItems.splice(this._creatingTreeItems.indexOf(creatingTreeItem), 1);
                        this.treeDataProvider.refreshUIOnly(this);
                    }
                }
            }
            else {
                throw new errors_1.NotImplementedError('createChildImpl', this);
            }
        });
    }
    compareChildrenImpl(item1, item2) {
        return item1.effectiveLabel.localeCompare(item2.effectiveLabel);
    }
    pickChildTreeItem(expectedContextValues, context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pickTreeItemImpl) {
                const children = yield this.getCachedChildren(context);
                const pickedItem = yield this.pickTreeItemImpl(expectedContextValues);
                if (pickedItem) {
                    const child = children.find((ti) => ti.fullId === pickedItem.fullId);
                    if (child) {
                        return child;
                    }
                }
            }
            const placeHolder = localize_1.localize('selectTreeItem', 'Select {0}', this.childTypeLabel);
            let getTreeItem;
            try {
                getTreeItem = (yield extensionVariables_1.ext.ui.showQuickPick(this.getQuickPicks(expectedContextValues, context), { placeHolder })).data;
            }
            catch (error) {
                // We want the loading thing to show for `showQuickPick` but we also need to support autoSelect and canPickMany based on the value of the picks
                // hence throwing an error instead of just awaiting `getQuickPicks`
                if (error instanceof AutoSelectError) {
                    getTreeItem = error.data;
                }
                else if (error instanceof CanPickManyError) {
                    const result = (yield extensionVariables_1.ext.ui.showQuickPick(error.picks, { placeHolder, canPickMany: true }));
                    return yield Promise.all(result.map((pick) => __awaiter(this, void 0, void 0, function* () { return yield pick.data(); })));
                }
                else {
                    throw error;
                }
            }
            return yield getTreeItem();
        });
    }
    addChildToCache(childToAdd) {
        if (!this._cachedChildren.find((ti) => ti.fullId === childToAdd.fullId)) {
            // set index to the last element by default
            let index = this._cachedChildren.length;
            // tslint:disable-next-line:no-increment-decrement
            for (let i = 0; i < this._cachedChildren.length; i++) {
                if (childToAdd.label.localeCompare(this._cachedChildren[i].label) < 1) {
                    index = i;
                    break;
                }
            }
            this._cachedChildren.splice(index, 0, childToAdd);
            this.treeDataProvider.refreshUIOnly(this);
        }
    }
    removeChildFromCache(childToRemove) {
        const index = this._cachedChildren.indexOf(childToRemove);
        if (index !== -1) {
            this._cachedChildren.splice(index, 1);
            this.treeDataProvider.refreshUIOnly(this);
        }
    }
    loadMoreChildren(context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._loadMoreChildrenTask) {
                yield this._loadMoreChildrenTask;
            }
            else {
                this._loadMoreChildrenTask = this.loadMoreChildrenInternal(context);
                try {
                    yield this._loadMoreChildrenTask;
                }
                finally {
                    this._loadMoreChildrenTask = undefined;
                }
            }
        });
    }
    loadAllChildren(context) {
        return __awaiter(this, void 0, void 0, function* () {
            context.loadingMessage = context.loadingMessage || localize_1.localize('loadingTreeItem', 'Loading "{0}"...', this.label);
            yield runWithLoadingNotification_1.runWithLoadingNotification(context, (cancellationToken) => __awaiter(this, void 0, void 0, function* () {
                do {
                    if (cancellationToken.isCancellationRequested) {
                        context.telemetry.properties.cancelStep = 'loadAllChildren';
                        throw new errors_1.UserCancelledError();
                    }
                    yield this.loadMoreChildren(context);
                } while (this.hasMoreChildrenImpl());
            }));
            return this._cachedChildren;
        });
    }
    createTreeItemsWithErrorHandling(sourceArray, invalidContextValue, createTreeItem, getLabelOnError) {
        return __awaiter(this, void 0, void 0, function* () {
            const treeItems = [];
            let lastUnknownItemError;
            // tslint:disable-next-line: strict-boolean-expressions
            sourceArray = sourceArray || [];
            yield Promise.all(sourceArray.map((source) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const item = yield createTreeItem(source);
                    if (item) {
                        // Verify at least the following properties can be accessed without an error
                        // tslint:disable: no-unused-expression
                        item.contextValue;
                        item.description;
                        item.label;
                        item.iconPath;
                        item.id;
                        // tslint:enable: no-unused-expression
                        treeItems.push(item);
                    }
                }
                catch (error) {
                    let name;
                    try {
                        name = yield getLabelOnError(source);
                    }
                    catch (_a) {
                        // ignore
                    }
                    if (name) {
                        treeItems.push(new InvalidTreeItem(this, error, {
                            label: name,
                            contextValue: invalidContextValue,
                            data: source
                        }));
                    }
                    else if (!util_1.isNullOrUndefined(error)) {
                        lastUnknownItemError = error;
                    }
                }
            })));
            if (!util_1.isNullOrUndefined(lastUnknownItemError)) {
                // Display a generic error if there are any unknown items. Only the last error will be displayed
                const label = localize_1.localize('cantShowItems', 'Some items could not be displayed');
                treeItems.push(new InvalidTreeItem(this, lastUnknownItemError, {
                    label,
                    description: '',
                    contextValue: invalidContextValue
                }));
            }
            return treeItems;
        });
    }
    loadMoreChildrenInternal(context) {
        return __awaiter(this, void 0, void 0, function* () {
            this._isLoadingMore = true;
            try {
                this.treeDataProvider.refreshUIOnly(this);
                if (this._clearCache) {
                    // Just in case implementers of `loadMoreChildrenImpl` re-use the same child node, we want to clear those caches as well
                    for (const child of this._cachedChildren) {
                        if (InternalInterfaces_1.isAzExtParentTreeItem(child)) {
                            child.clearCache();
                        }
                    }
                    this._cachedChildren = [];
                }
                else if (!this.hasMoreChildrenImpl()) {
                    // No-op since all children are already loaded
                    return;
                }
                const newTreeItems = yield this.loadMoreChildrenImpl(this._clearCache, context);
                this._cachedChildren = this._cachedChildren.concat(newTreeItems).sort((ti1, ti2) => this.compareChildrenImpl(ti1, ti2));
            }
            finally {
                this._clearCache = false;
                this._isLoadingMore = false;
                this.treeDataProvider.refreshUIOnly(this);
            }
        });
    }
    getQuickPicks(expectedContextValues, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let children = yield this.getCachedChildren(context);
            children = children.filter((ti) => ti.includeInTreePicker(expectedContextValues));
            let autoSelectInTreeItemPicker = this.autoSelectInTreeItemPicker;
            const picks = children.map((ti) => {
                if (ti instanceof GenericTreeItem_1.GenericTreeItem) {
                    // Don't auto-select a command tree item
                    autoSelectInTreeItemPicker = false;
                    return {
                        label: ti.label,
                        description: ti.description,
                        id: ti.fullId,
                        data: () => __awaiter(this, void 0, void 0, function* () {
                            if (!ti.commandId) {
                                throw new Error(localize_1.localize('noCommand', 'Failed to find commandId on generic tree item.'));
                            }
                            else {
                                // tslint:disable-next-line: strict-boolean-expressions
                                const commandArgs = ti.commandArgs || [ti];
                                yield vscode_1.commands.executeCommand(ti.commandId, ...commandArgs);
                                yield this.refresh();
                                return this;
                            }
                        })
                    };
                }
                else {
                    return {
                        label: ti.label,
                        description: ti.description,
                        id: ti.fullId,
                        data: () => __awaiter(this, void 0, void 0, function* () { return yield Promise.resolve(ti); })
                    };
                }
            });
            if (this.createChildImpl && this.childTypeLabel && !context.suppressCreatePick) {
                const createNewLabel = this.createNewLabel || localize_1.localize('treePickerCreateNew', 'Create new {0}...', this.childTypeLabel);
                if (this.supportsAdvancedCreation) {
                    picks.unshift({
                        label: `$(plus) ${createNewLabel}`,
                        description: localize_1.localize('advanced', 'Advanced'),
                        data: () => __awaiter(this, void 0, void 0, function* () { return yield this.createChild(Object.assign(context, { advancedCreation: true })); })
                    });
                }
                picks.unshift({
                    label: `$(plus) ${createNewLabel}`,
                    data: () => __awaiter(this, void 0, void 0, function* () { return yield this.createChild(context); })
                });
            }
            if (this.hasMoreChildrenImpl()) {
                picks.push({
                    label: `$(sync) ${treeConstants_1.loadMoreLabel}`,
                    description: '',
                    data: () => __awaiter(this, void 0, void 0, function* () {
                        yield this.treeDataProvider.loadMore(this, context);
                        return this;
                    })
                });
            }
            if (picks.length === 0) {
                throw new errors_1.NoResouceFoundError(context);
            }
            else if (picks.length === 1 && autoSelectInTreeItemPicker) {
                throw new AutoSelectError(picks[0].data);
            }
            else if (context.canPickMany && children.some(c => c.matchesContextValue(expectedContextValues))) {
                // canPickMany is only supported at the last stage of the picker, so only throw this error if some of the picks match
                throw new CanPickManyError(picks);
            }
            return picks;
        });
    }
}
exports.AzExtParentTreeItem = AzExtParentTreeItem;
class InvalidTreeItem extends AzExtParentTreeItem {
    constructor(parent, error, options) {
        super(parent);
        this.label = options.label;
        this._error = error;
        this.contextValue = options.contextValue;
        this.data = options.data;
        this.description = options.description !== undefined ? options.description : localize_1.localize('invalid', 'Invalid');
    }
    get id() {
        // `id` doesn't really matter for invalid items, but we want to avoid duplicates since that could break the tree
        return randomUtils_1.randomUtils.getRandomHexString(16);
    }
    get iconPath() {
        return IconPath_1.getThemedIconPath('warning');
    }
    loadMoreChildrenImpl() {
        return __awaiter(this, void 0, void 0, function* () {
            throw this._error;
        });
    }
    hasMoreChildrenImpl() {
        return false;
    }
    isAncestorOfImpl() {
        // never display invalid items in tree picker
        return false;
    }
}
exports.InvalidTreeItem = InvalidTreeItem;
class AutoSelectError extends Error {
    constructor(data) {
        super();
        this.data = data;
    }
}
class CanPickManyError extends Error {
    constructor(picks) {
        super();
        this.picks = picks;
    }
}
//# sourceMappingURL=AzExtParentTreeItem.js.map
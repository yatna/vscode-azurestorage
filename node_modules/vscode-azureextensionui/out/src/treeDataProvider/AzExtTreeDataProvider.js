"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = require("vscode");
const callWithTelemetryAndErrorHandling_1 = require("../callWithTelemetryAndErrorHandling");
const errors_1 = require("../errors");
const localize_1 = require("../localize");
const parseError_1 = require("../parseError");
const GenericTreeItem_1 = require("./GenericTreeItem");
const IconPath_1 = require("./IconPath");
const InternalInterfaces_1 = require("./InternalInterfaces");
const runWithLoadingNotification_1 = require("./runWithLoadingNotification");
const treeConstants_1 = require("./treeConstants");
class AzExtTreeDataProvider {
    constructor(rootTreeItem, loadMoreCommandId) {
        this._onTreeItemCreateEmitter = new vscode_1.EventEmitter();
        this._onDidChangeTreeDataEmitter = new vscode_1.EventEmitter();
        this._findTreeItemTasks = new Map();
        this._loadMoreCommandId = loadMoreCommandId;
        this._rootTreeItem = rootTreeItem;
        rootTreeItem.treeDataProvider = this;
    }
    get onDidChangeTreeData() {
        return this._onDidChangeTreeDataEmitter.event;
    }
    get onTreeItemCreate() {
        return this._onTreeItemCreateEmitter.event;
    }
    getTreeItem(treeItem) {
        return {
            label: treeItem.effectiveLabel,
            id: treeItem.fullId,
            collapsibleState: treeItem.collapsibleState,
            contextValue: treeItem.contextValue,
            iconPath: treeItem.effectiveIconPath,
            command: treeItem.commandId ? {
                command: treeItem.commandId,
                title: '',
                // tslint:disable-next-line: strict-boolean-expressions
                arguments: treeItem.commandArgs || [treeItem]
            } : undefined
        };
    }
    getChildren(treeItem) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield callWithTelemetryAndErrorHandling_1.callWithTelemetryAndErrorHandling('AzureTreeDataProvider.getChildren', (context) => __awaiter(this, void 0, void 0, function* () {
                    context.errorHandling.suppressDisplay = true;
                    context.errorHandling.rethrow = true;
                    let result;
                    if (!treeItem) {
                        context.telemetry.properties.isActivationEvent = 'true';
                        treeItem = this._rootTreeItem;
                    }
                    context.telemetry.properties.contextValue = treeItem.contextValue;
                    const cachedChildren = yield treeItem.getCachedChildren(context);
                    const hasMoreChildren = treeItem.hasMoreChildrenImpl();
                    context.telemetry.properties.hasMoreChildren = String(hasMoreChildren);
                    result = treeItem.creatingTreeItems.concat(cachedChildren);
                    if (hasMoreChildren && !treeItem._isLoadingMore) {
                        const loadMoreTI = new GenericTreeItem_1.GenericTreeItem(treeItem, {
                            label: treeConstants_1.loadMoreLabel,
                            iconPath: IconPath_1.getThemedIconPath('refresh'),
                            contextValue: 'azureextensionui.loadMore',
                            commandId: this._loadMoreCommandId
                        });
                        loadMoreTI.commandArgs = [treeItem];
                        result.push(loadMoreTI);
                    }
                    context.telemetry.measurements.childCount = result.length;
                    return result;
                }));
            }
            catch (error) {
                return [new GenericTreeItem_1.GenericTreeItem(treeItem, {
                        label: localize_1.localize('errorTreeItem', 'Error: {0}', parseError_1.parseError(error).message),
                        contextValue: 'azureextensionui.error'
                    })];
            }
        });
    }
    refresh(treeItem) {
        return __awaiter(this, void 0, void 0, function* () {
            // tslint:disable-next-line: strict-boolean-expressions
            treeItem = treeItem || this._rootTreeItem;
            if (treeItem.refreshImpl) {
                yield treeItem.refreshImpl();
            }
            if (InternalInterfaces_1.isAzExtParentTreeItem(treeItem)) {
                treeItem.clearCache();
            }
            this.refreshUIOnly(treeItem);
        });
    }
    refreshUIOnly(_treeItem) {
        // Pass undefined as temporary workaround for https://github.com/microsoft/vscode/issues/71698
        this._onDidChangeTreeDataEmitter.fire(undefined);
        // this._onDidChangeTreeDataEmitter.fire(treeItem === this._rootTreeItem ? undefined : treeItem);
    }
    loadMore(treeItem, context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield treeItem.loadMoreChildren(context);
        });
    }
    showTreeItemPicker(expectedContextValues, context, startingTreeItem) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!Array.isArray(expectedContextValues)) {
                expectedContextValues = [expectedContextValues];
            }
            // tslint:disable-next-line:strict-boolean-expressions
            let treeItem = startingTreeItem || this._rootTreeItem;
            while (!treeItem.matchesContextValue(expectedContextValues)) {
                if (InternalInterfaces_1.isAzExtParentTreeItem(treeItem)) {
                    const pickedItems = yield treeItem.pickChildTreeItem(expectedContextValues, context);
                    if (Array.isArray(pickedItems)) {
                        // canPickMany is only supported at the last stage of the picker, so automatically return if this is an array
                        return pickedItems;
                    }
                    else {
                        treeItem = pickedItems;
                    }
                }
                else {
                    throw new errors_1.NoResouceFoundError(context);
                }
            }
            return treeItem;
        });
    }
    getParent(treeItem) {
        return __awaiter(this, void 0, void 0, function* () {
            return treeItem.parent === this._rootTreeItem ? undefined : treeItem.parent;
        });
    }
    findTreeItem(fullId, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            const existingTask = this._findTreeItemTasks.get(fullId);
            if (existingTask) {
                result = yield existingTask;
            }
            else {
                const newTask = this.findTreeItemInternal(fullId, context);
                this._findTreeItemTasks.set(fullId, newTask);
                try {
                    result = yield newTask;
                }
                finally {
                    this._findTreeItemTasks.delete(fullId);
                }
            }
            return result;
        });
    }
    /**
     * Wrapped by `findTreeItem` to ensure only one find is happening per `fullId` at a time
     */
    findTreeItemInternal(fullId, context) {
        return __awaiter(this, void 0, void 0, function* () {
            let treeItem = this._rootTreeItem;
            return yield runWithLoadingNotification_1.runWithLoadingNotification(context, (cancellationToken) => __awaiter(this, void 0, void 0, function* () {
                // tslint:disable-next-line: no-constant-condition
                outerLoop: while (true) {
                    if (cancellationToken.isCancellationRequested) {
                        context.telemetry.properties.cancelStep = 'findTreeItem';
                        throw new errors_1.UserCancelledError();
                    }
                    const children = yield treeItem.getCachedChildren(context);
                    for (const child of children) {
                        if (child.fullId === fullId) {
                            return child;
                        }
                        else if (isAncestor(child, fullId)) {
                            treeItem = child;
                            continue outerLoop;
                        }
                    }
                    if (context.loadAll && treeItem.hasMoreChildrenImpl()) {
                        yield treeItem.loadMoreChildren(context);
                    }
                    else {
                        return undefined;
                    }
                }
            }));
        });
    }
}
exports.AzExtTreeDataProvider = AzExtTreeDataProvider;
function isAncestor(treeItem, fullId) {
    // Append '/' to 'treeItem.fullId' when checking 'startsWith' to ensure its actually an ancestor, rather than a treeItem at the same level that _happens_ to start with the same id
    // For example, two databases named 'test' and 'test1' as described in this issue: https://github.com/Microsoft/vscode-cosmosdb/issues/488
    return fullId.startsWith(`${treeItem.fullId}/`) && InternalInterfaces_1.isAzExtParentTreeItem(treeItem);
}
//# sourceMappingURL=AzExtTreeDataProvider.js.map